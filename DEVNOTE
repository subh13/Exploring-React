v0.1 (L1)
    A) Load multiple components using react.
    B) Static components as well dynamic components using props.
v0.2 (L3)
    A) Component as a ES6 function not as a class.
    B) Component ES6 function props and reserved keyword children handling.
    c) state management using react default state management (change a single state object variable, change the whole array of object of a particular state variable).
    D) Access parent function from child components using passing reference to the function by props.
    E) Used bind to pass params to the function.
    F) 2 way data binding.
v0.3 (L4)
    A) List and conditional operator.
    B) Splice and slice operator.
    C) Skip state mutation. Rather use spread operator.
    D) Use key always in a loop or map.
    E) Javascript is reference type so every function call is a reference to that function itself.
v0.4 (L5)
    A) Digging deeper to styling.
    B) Installation of Radium package for hover and other psudo classes of css.
    C) Used StyleRoot in media query for Radium.
    D) npm eject to unlock the feature of scoped styling. i.e same class name could not be overwritten. Configure webpack.dev and webpack.prod in config folder which will be autogenerated after npm eject.
v0.5 (L6)
    A) Worked with developer tool React and Errorhandler. i.e ErrorBoundary.
v0.6 (L7)
    A) HOC - Higher Order Component.
    B) FYI every stateless Component should return something if its a HOC it should return something wrapped in a parent i.e. div
            eg. const mainContainer = (props) => { {props.childern} }; is wrong.
            now what is right ? 
            const mainContainer = (props) => { 
                return <StyleRoot>{props.childern}</StyleRoot> 
            };
            1) Have one return statement.
            2) wrapped in a parent i.e StyleRoot -> for hover and all other Psudo classes by Radium.
    c) If there is no div parent while returning one Component. You can use Array instead [].
    D) Always use HOC as wrapped function way export default YourHocClassName(App, 'class-name');
    E) It could br statefull or stateless.
    F) SetState with two params prevState and props. The better approach.
    G) npm i --save prop-types for validating incoming props. i.e Only works with statefull component
    H) Use references in statefull components.
    I) usage of Context.
    J) Life cycle hook getSnapShotBeforeUpdate() is a great place to snap the scrolling positon of a user. And After componentDidUpdate() return the user to the same scrolling position.